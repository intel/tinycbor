/****************************************************************************
**
** Copyright (C) 2021 Intel Corporation
**
** Permission is hereby granted, free of charge, to any person obtaining a copy
** of this software and associated documentation files (the "Software"), to deal
** in the Software without restriction, including without limitation the rights
** to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
** copies of the Software, and to permit persons to whom the Software is
** furnished to do so, subject to the following conditions:
**
** The above copyright notice and this permission notice shall be included in
** all copies or substantial portions of the Software.
**
** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
** IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
** FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
** AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
** LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
** OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
** THE SOFTWARE.
**
****************************************************************************/

#ifndef CBOR_H
#define CBOR_H

#ifndef assert
#include <assert.h>
#endif
#include <limits.h>
#include <stddef.h>
#include <stdint.h>
#include <string.h>
#include <stdio.h>

#ifdef CBOR_EXTERNAL_CFG
#include "cbor_cfg.h"
#endif

#include "tinycbor-version.h"

#define TINYCBOR_VERSION            ((TINYCBOR_VERSION_MAJOR << 16) | (TINYCBOR_VERSION_MINOR << 8) | TINYCBOR_VERSION_PATCH)

#ifdef __cplusplus
extern "C" {
#else
#include <stdbool.h>
#endif

#ifndef SIZE_MAX
/* Some systems fail to define SIZE_MAX in <stdint.h>, even though C99 requires it...
 * Conversion from signed to unsigned is defined in 6.3.1.3 (Signed and unsigned integers) p2,
 * which says: "the value is converted by repeatedly adding or subtracting one more than the
 * maximum value that can be represented in the new type until the value is in the range of the
 * new type."
 * So -1 gets converted to size_t by adding SIZE_MAX + 1, which results in SIZE_MAX.
 */
#  define SIZE_MAX ((size_t)-1)
#endif

#ifndef CBOR_API
#  define CBOR_API
#endif
#ifndef CBOR_PRIVATE_API
#  define CBOR_PRIVATE_API
#endif
#ifndef CBOR_INLINE_API
#  if defined(__cplusplus)
#    define CBOR_INLINE inline
#    define CBOR_INLINE_API inline
#  else
#    define CBOR_INLINE_API static CBOR_INLINE
#    if defined(_MSC_VER)
#      define CBOR_INLINE __inline
#    elif defined(__GNUC__)
#      define CBOR_INLINE __inline__
#    elif defined(__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
#      define CBOR_INLINE inline
#    else
#      define CBOR_INLINE
#    endif
#  endif
#endif

typedef enum CborType {
    CborIntegerType     = 0x00,
    CborByteStringType  = 0x40,
    CborTextStringType  = 0x60,
    CborArrayType       = 0x80,
    CborMapType         = 0xa0,
    CborTagType         = 0xc0,
    CborSimpleType      = 0xe0,
    CborBooleanType     = 0xf5,
    CborNullType        = 0xf6,
    CborUndefinedType   = 0xf7,
    CborHalfFloatType   = 0xf9,
    CborFloatType       = 0xfa,
    CborDoubleType      = 0xfb,

    CborInvalidType     = 0xff              /* equivalent to the break byte, so it will never be used */
} CborType;

typedef enum CborSimpleValue {
  /* Autogenerated IANA CBOR Content-Formats (Source: https://www.iana.org/assignments/cbor-simple-values/cbor-simple-values.xhtml#simple) */

  /* 0-19 : Standards Action */
  // False; Ref: [RFC8949]
  CborSimpleValueFalse = 20,
  // True; Ref: [RFC8949]
  CborSimpleValueTrue = 21,
  // Null; Ref: [RFC8949]
  CborSimpleValueNull = 22,
  // Undefined; Ref: [RFC8949]
  CborSimpleValueUndefined = 23

  /* 32-255 : Specification Required */
} CborSimpleValue;

typedef uint64_t CborTag;
typedef enum CborKnownTags {
  /* Autogenerated IANA CBOR Tags (Source: https://www.iana.org/assignments/cbor-tags/cbor-tags.xhtml#tags) */

  /* 0-23 : Standards Action */
  // Standard date/time string; see Section 3.4.1; Ref: [RFC8949]
  CborDateTimeStringTag = 0,
  // Epoch-based date/time; see Section 3.4.2; Ref: [RFC8949]
  CborUnixTime_tTag = 1,
  // Unsigned bignum; see Section 3.4.3; Ref: [RFC8949]
  CborPositiveBignumTag = 2,
  // Negative bignum; see Section 3.4.3; Ref: [RFC8949]
  CborNegativeBignumTag = 3,
  // Decimal fraction; see Section 3.4.4; Ref: [RFC8949]
  CborDecimalTag = 4,
  // Bigfloat; see Section 3.4.4; Ref: [RFC8949]
  CborBigfloatTag = 5,
  // COSE Single Recipient Encrypted Data Object; Ref: [RFC9052]
  CborCOSE_Encrypt0Tag = 16,
  // COSE Mac w/o Recipients Object; Ref: [RFC9052]
  CborCOSE_Mac0Tag = 17,
  // COSE Single Signer Data Object; Ref: [RFC9052]
  CborCOSE_Sign1Tag = 18,
  // COSE standalone V2 countersignature; Ref: [RFC9338]
  CborKnownTCoseStandaloneV2CountersignatureTag = 19,
  // Expected conversion to base64url encoding; see Section 3.4.5.2; Ref: [RFC8949]
  CborExpectedBase64urlTag = 21,
  // Expected conversion to base64 encoding; see Section 3.4.5.2; Ref: [RFC8949]
  CborExpectedBase64Tag = 22,
  // Expected conversion to base16 encoding; see Section 3.4.5.2; Ref: [RFC8949]
  CborExpectedBase16Tag = 23,

  /* 24-32767 : Specification Required */
  // Encoded CBOR data item; see Section 3.4.5.1; Ref: [RFC8949]
  CborEncodedCborTag = 24,
  // reference the nth previously seen string; Ref: [http://cbor.schmorp.de/stringref][Marc_A._Lehmann]
  CborKnownTRefTheNthPrevSeenStringTag = 25,
  // Serialised Perl object with classname and constructor arguments; Ref: [http://cbor.schmorp.de/perl-object][Marc_A._Lehmann]
  CborKnownTSerialisedPerlObjWithClassnameConstructorArgTag = 26,
  // Serialised language-independent object with type name and constructor arguments; Ref: [http://cbor.schmorp.de/generic-object][Marc_A._Lehmann]
  CborKnownTSerialisedLangIndepObjWithTypeNameConstructorArgTag = 27,
  // mark value as (potentially) shared; Ref: [http://cbor.schmorp.de/value-sharing][Marc_A._Lehmann]
  CborKnownTMarkValueAsSharedTag = 28,
  // reference nth marked value; Ref: [http://cbor.schmorp.de/value-sharing][Marc_A._Lehmann]
  CborKnownTRefNthMarkedValueTag = 29,
  // Rational number; Ref: [http://peteroupc.github.io/CBOR/rational.html][Peter_Occil]
  CborKnownTRationalNumberTag = 30,
  // Absent value in a CBOR Array; Ref: [https://github.com/svaarala/cbor-specs/blob/master/cbor-absent-tag.rst][Sami_Vaarala]
  CborKnownTAbsentValueInACborArrayTag = 31,
  // URI; see Section 3.4.5.3; Ref: [RFC8949]
  CborUrlTag = 32,
  // base64url; see Section 3.4.5.3; Ref: [RFC8949]
  CborBase64urlTag = 33,
  // base64; see Section 3.4.5.3; Ref: [RFC8949]
  CborBase64Tag = 34,
  // Regular expression; see Section 2.4.4.3; Ref: [RFC7049]
  CborRegularExpressionTag = 35,
  // MIME message; see Section 3.4.5.3; Ref: [RFC8949]
  CborMimeMessageTag = 36,
  // Binary UUID ([RFC4122, Section 4.1.2]); Ref: [https://github.com/lucas-clemente/cbor-specs/blob/master/uuid.md][Lucas_Clemente]
  CborKnownTBinaryUuidTag = 37,
  // Language-tagged string; Ref: [RFC9290, Appendix A]
  CborKnownTLanguageTaggedStringTag = 38,
  // Identifier; Ref: [https://github.com/lucas-clemente/cbor-specs/blob/master/id.md][Lucas_Clemente]
  CborKnownTIdTag = 39,
  // Multi-dimensional Array, row-major order; Ref: [RFC8746]
  CborKnownTMultiDimensionalArrayRowMajorOrderTag = 40,
  // Homogeneous Array; Ref: [RFC8746]
  CborKnownTHomogeneousArrayTag = 41,
  // IPLD content identifier; Ref: [https://github.com/ipld/cid-cbor/][Volker_Mische]
  CborKnownTIpldContentIdTag = 42,
  // YANG bits datatype; see Section 6.7.; Ref: [RFC9254]
  CborKnownTYangBitsDatatypeTag = 43,
  // YANG enumeration datatype; see Section 6.6.; Ref: [RFC9254]
  CborKnownTYangEnumerationDatatypeTag = 44,
  // YANG identityref datatype; see Section 6.10.; Ref: [RFC9254]
  CborKnownTYangIdentityrefDatatypeTag = 45,
  // YANG instance-identifier datatype; see Section 6.13.; Ref: [RFC9254]
  CborKnownTYangInstanceIdDatatypeTag = 46,
  // YANG Schema Item iDentifier (sid); see Section 3.2.; Ref: [RFC9254]
  CborKnownTYangSchemaItemIdTag = 47,
  // IPv4, [prefixlen,IPv4], [IPv4,prefixpart]; Ref: [RFC9164]
  CborKnownTIpv4Tag = 52,
  // IPv6, [prefixlen,IPv6], [IPv6,prefixpart]; Ref: [RFC9164]
  CborKnownTIpv6Tag = 54,
  // CBOR Web Token (CWT); Ref: [RFC8392][Michael_B._Jones]
  CborKnownTCborWebTokenTag = 61,
  // Encoded CBOR Sequence [RFC8742]; Ref: [draft-bormann-cbor-notable-tags-02, Section 2.1]
  CborKnownTEncodedCborSequenceTag = 63,
  // uint8 Typed Array; Ref: [RFC8746]
  CborKnownTUint8TypedArrayTag = 64,
  // uint16, big endian, Typed Array; Ref: [RFC8746]
  CborKnownTUint16BigEndianTypedArrayTag = 65,
  // uint32, big endian, Typed Array; Ref: [RFC8746]
  CborKnownTUint32BigEndianTypedArrayTag = 66,
  // uint64, big endian, Typed Array; Ref: [RFC8746]
  CborKnownTUint64BigEndianTypedArrayTag = 67,
  // uint8 Typed Array, clamped arithmetic; Ref: [RFC8746]
  CborKnownTUint8TypedArrayClampedArithmeticTag = 68,
  // uint16, little endian, Typed Array; Ref: [RFC8746]
  CborKnownTUint16LittleEndianTypedArrayTag = 69,
  // uint32, little endian, Typed Array; Ref: [RFC8746]
  CborKnownTUint32LittleEndianTypedArrayTag = 70,
  // uint64, little endian, Typed Array; Ref: [RFC8746]
  CborKnownTUint64LittleEndianTypedArrayTag = 71,
  // sint8 Typed Array; Ref: [RFC8746]
  CborKnownTSint8TypedArrayTag = 72,
  // sint16, big endian, Typed Array; Ref: [RFC8746]
  CborKnownTSint16BigEndianTypedArrayTag = 73,
  // sint32, big endian, Typed Array; Ref: [RFC8746]
  CborKnownTSint32BigEndianTypedArrayTag = 74,
  // sint64, big endian, Typed Array; Ref: [RFC8746]
  CborKnownTSint64BigEndianTypedArrayTag = 75,
  // sint16, little endian, Typed Array; Ref: [RFC8746]
  CborKnownTSint16LittleEndianTypedArrayTag = 77,
  // sint32, little endian, Typed Array; Ref: [RFC8746]
  CborKnownTSint32LittleEndianTypedArrayTag = 78,
  // sint64, little endian, Typed Array; Ref: [RFC8746]
  CborKnownTSint64LittleEndianTypedArrayTag = 79,
  // IEEE 754 binary16, big endian, Typed Array; Ref: [RFC8746]
  CborKnownTIeee754Binary16BigEndianTypedArrayTag = 80,
  // IEEE 754 binary32, big endian, Typed Array; Ref: [RFC8746]
  CborKnownTIeee754Binary32BigEndianTypedArrayTag = 81,
  // IEEE 754 binary64, big endian, Typed Array; Ref: [RFC8746]
  CborKnownTIeee754Binary64BigEndianTypedArrayTag = 82,
  // IEEE 754 binary128, big endian, Typed Array; Ref: [RFC8746]
  CborKnownTIeee754Binary128BigEndianTypedArrayTag = 83,
  // IEEE 754 binary16, little endian, Typed Array; Ref: [RFC8746]
  CborKnownTIeee754Binary16LittleEndianTypedArrayTag = 84,
  // IEEE 754 binary32, little endian, Typed Array; Ref: [RFC8746]
  CborKnownTIeee754Binary32LittleEndianTypedArrayTag = 85,
  // IEEE 754 binary64, little endian, Typed Array; Ref: [RFC8746]
  CborKnownTIeee754Binary64LittleEndianTypedArrayTag = 86,
  // IEEE 754 binary128, little endian, Typed Array; Ref: [RFC8746]
  CborKnownTIeee754Binary128LittleEndianTypedArrayTag = 87,
  // COSE Encrypted Data Object; Ref: [RFC9052]
  CborCOSE_EncryptTag = 96,
  // COSE MACed Data Object; Ref: [RFC9052]
  CborCOSE_MacTag = 97,
  // COSE Signed Data Object; Ref: [RFC9052]
  CborCOSE_SignTag = 98,
  // Number of days since the epoch date 1970-01-01; Ref: [RFC8943]
  CborKnownTNumberOfDaysSinceTheEpochDate19700101Tag = 100,
  // alternatives as given by the uint + 128; see Section 9.1; Ref: [draft-bormann-cbor-notable-tags-07]
  CborKnownTAlternativesAsGivenByTheUintPlus128Tag = 101,
  // Geographic Coordinates; Ref: [https://github.com/allthingstalk/cbor/blob/master/CBOR-Tag103-Geographic-Coordinates.md][Danilo_Vidovic]
  CborKnownTGeographicCoordinatesTag = 103,
  // Geographic Coordinate Reference System WKT or EPSG number; Ref: [draft-clarke-cbor-crs]
  CborKnownTGeoCoordRefSystemWktOrEpsgNumTag = 104,
  // relative object identifier (BER encoding); SDNV [RFC6256] sequence; Ref: [RFC9090]
  CborKnownTRelativeObjectIdTag = 110,
  // object identifier (BER encoding); Ref: [RFC9090]
  CborKnownTObjectIdTag = 111,
  // object identifier (BER encoding), relative to 1.3.6.1.4.1; Ref: [RFC9090]
  CborKnownTObjectIdRelativeTo136141Tag = 112,
  // Internet of Things Data Point; Ref: [https://github.com/allthingstalk/cbor/blob/master/CBOR-Tag120-Internet-of-Things-Data-Points.md][Danilo_Vidovic]
  CborKnownTInternetOfThingsDataPointTag = 120,
  // Gordian Envelope; Ref: [draft-mcnally-envelope-05]
  CborKnownTGordianEnvelopeTag = 200,
  // mark value as having string references; Ref: [http://cbor.schmorp.de/stringref][Marc_A._Lehmann]
  CborKnownTMarkValueAsHavingStringReferencesTag = 256,
  // Binary MIME message; Ref: [http://peteroupc.github.io/CBOR/binarymime.html][Peter_Occil]
  CborKnownTBinaryMimeMsgTag = 257,
  // Mathematical finite set; Ref: [https://github.com/input-output-hk/cbor-sets-spec/blob/master/CBOR_SETS.md][Alfredo_Di_Napoli]
  CborKnownTMathematicalFiniteSetTag = 258,
  // Map datatype with key-value operations (e.g. `.get()/.set()/.delete()`); Ref: [https://github.com/shanewholloway/js-cbor-codec/blob/master/docs/CBOR-259-spec--explicit-maps.md][Shane_Holloway]
  CborKnownTMapDatatypeWithKeyValOpSetDeleteTag = 259,
  // Network Address (IPv4 or IPv6 or MAC Address) (DEPRECATED in favor of 52 and 54        for IP addresses); Ref: [http://www.employees.org/~ravir/cbor-network.txt][Ravi_Raju][RFC9164]
  CborKnownTNetworkAddressTag = 260,
  // Network Address Prefix (IPv4 or IPv6 Address + Mask Length) (DEPRECATED in favor of 52 and 54        for IP addresses); Ref: [https://github.com/toravir/CBOR-Tag-Specs/blob/master/networkPrefix.md][Ravi_Raju][RFC9164]
  CborKnownTNetworkAddressPrefixTag = 261,
  // Embedded JSON Object; Ref: [https://github.com/toravir/CBOR-Tag-Specs/blob/master/embeddedJSON.md][Ravi_Raju]
  CborKnownTEmbeddedJsonObjectTag = 262,
  // Hexadecimal string; Ref: [https://github.com/toravir/CBOR-Tag-Specs/blob/master/hexString.md][Ravi_Raju]
  CborKnownTHexadecimalStringTag = 263,
  // Decimal fraction with arbitrary exponent; Ref: [http://peteroupc.github.io/CBOR/bigfrac.html][Peter_Occil]
  CborKnownTDecimalFractionWithArbitraryExponentTag = 264,
  // Bigfloat with arbitrary exponent; Ref: [http://peteroupc.github.io/CBOR/bigfrac.html][Peter_Occil]
  CborKnownTBigfloatWithArbitraryExponentTag = 265,
  // Internationalized resource identifier (IRI); Ref: [https://peteroupc.github.io/CBOR/iri.html][Peter_Occil]
  CborKnownTInternationalizedResourceIdTag = 266,
  // Internationalized resource identifier reference (IRI reference); Ref: [https://peteroupc.github.io/CBOR/iri.html][Peter_Occil]
  CborKnownTInternationalizedResourceIdRefTag = 267,
  // Extended decimal fraction; Ref: [https://peteroupc.github.io/CBOR/extended.html][Peter_Occil]
  CborKnownTExtendedDecimalFractionTag = 268,
  // Extended bigfloat; Ref: [https://peteroupc.github.io/CBOR/extended.html][Peter_Occil]
  CborKnownTExtendedBigfloatTag = 269,
  // Extended rational number; Ref: [https://peteroupc.github.io/CBOR/extended.html][Peter_Occil]
  CborKnownTExtendedRationalNumberTag = 270,
  // DDoS Open Threat Signaling (DOTS) signal channel object, as defined in [RFC9132]; Ref: [RFC9132]
  CborKnownTDdosOpenThreatSignalingSigChnObjTag = 271,
  // Non-UTF-8 CESU-8 string; Ref: [https://github.com/svaarala/cbor-specs/blob/master/cbor-nonutf8-string-tags.rst][Sami_Vaarala]
  CborKnownTNonUtf8Cesu8StringTag = 272,
  // Non-UTF-8 WTF-8 string; Ref: [https://github.com/svaarala/cbor-specs/blob/master/cbor-nonutf8-string-tags.rst][Sami_Vaarala]
  CborKnownTNonUtf8Wtf8StringTag = 273,
  // Non-UTF-8 MUTF-8 string; Ref: [https://github.com/svaarala/cbor-specs/blob/master/cbor-nonutf8-string-tags.rst][Sami_Vaarala]
  CborKnownTNonUtf8Mutf8StringTag = 274,
  // Map contains only keys that are of type Text String (major type 3); Ref: [https://github.com/ecorm/cbor-tag-text-key-map][Emile_Cormier]
  CborKnownTMapContainsOnlyKeysThatAreOfTypeTxtStrTag = 275,
  // ERIS binary read capability; Ref: [http://purl.org/eris]
  CborKnownTErisBinaryReadCapabilityTag = 276,
  // Universal Geographical Area Description (GAD) shape; see Section 5; Ref: [TS 23.032][Mathew_Meins]
  CborKnownTUniversalGeoAreaDescriptionShapeTag = 277,
  // Universal Geographical Area Description (GAD) description of velocity; see Section 8; Ref: [TS 23.032][Mathew_Meins]
  CborKnownTUniversalGeoAreaDescriptionDescriptionOfVelocityTag = 278,
  // extended time; Ref: [draft-bormann-cbor-time-tag-01]
  CborKnownTExtendedTimeTag = 1001,
  // duration; Ref: [draft-bormann-cbor-time-tag-01]
  CborKnownTDurationTag = 1002,
  // period; Ref: [draft-bormann-cbor-time-tag-01]
  CborKnownTPeriodTag = 1003,
  // [RFC3339] full-date string; Ref: [RFC8943]
  CborKnownTFullDateStringTag = 1004,
  // Object type identifier; Ref: [draft-rundgren-cotx-04]
  CborKnownTObjectTypeIdTag = 1010,
  // Multi-dimensional Array, column-major order; Ref: [RFC8746]
  CborKnownTMultiDimensionalArrayColumnMajorOrderTag = 1040,
  // [COSE algorithm identifier, Base Hash value]; Ref: [draft-bormann-cbor-notable-tags-09, Section 3.1.1]
  CborKnownTCoseAlgorithmIdBaseHashValueTag = 18556,
  // I-Regexp; Ref: [draft-bormann-cbor-notable-tags-09, Section 2.1][draft-ietf-jsonpath-iregexp-08]
  CborKnownTIRegexpTag = 21065,
  // ECMAScript RegExp [https://262.ecma-international.org/14.0/#sec-regexp-regular-expression-objects]; Ref: [https://github.com/hildjj/cbor-specs/blob/main/regexp.md][Joe_Hildebrand]
  CborKnownTEcmascriptRegexpTag = 21066,
  // hint that indicates an additional level of indirection; Ref: [http://cbor.schmorp.de/indirection][Marc_A._Lehmann]
  CborKnownTHintThatIndicatesAnAddLvlOfIndirectionTag = 22098,
  // Capture [3]; Ref: [https://github.com/japhb/cbor-specs/blob/main/capture.md][Geoffrey_Broadwell]
  CborKnownTCaptureTag = 25441,

  /* 32768-18446744073709551615 : First Come First Served */
  // Identifier for a FHIR constant; Ref: [Stefan_Genchev]
  CborKnownTIdForAFhirConstantTag = 32768,
  // External reference; Ref: [https://gitlab.com/Hawk777/cbor-specs/-/blob/main/external-reference.md][Christopher_Head]
  CborKnownTExternalRefTag = 32769,
  // A confidentiality clearance. The key value pairs of the map are defined in ADatP-4774.4; Ref: [Aidan_Murdock]
  CborKnownTAConfidentialityClearanceTag = 42600,
  // A metadata binding. The elements of the array are defined in AdatP-4778.5. The tag is also used as part of the magic number in on-disk detached and encapsulating bindings.; Ref: [Aidan_Murdock]
  CborKnownTAMetadataBindingTag = 42601,
  // A collection of NCMS metadata elements. The key value pairs of the map are defined in AdatP-5636.4; Ref: [Aidan_Murdock]
  CborKnownTACollectionOfNcmsMetadataElementsTag = 42602,
  // Single complex number: array elements are real (I) and imaginary (Q) components; Ref: [Saajan_Chana]
  CborKnownTSingleComplexNumberTag = 43000,
  // Array of complex numbers in interleaved form: complex value k is stored with real (I) part at array index 2k and imaginary (Q) part at index (2k + 1); Ref: [Saajan_Chana]
  CborKnownTArrayOfComplexNumbersInInterleavedFormTag = 43001,
  // PlatformV_IS_ID; Ref: [https://github.com/arthurwangtz/platformv-cbor][Wang_Tongzhou]
  CborKnownTPlatformvIsIdTag = 50000,
  // PlatformV_IS_NAME; Ref: [https://github.com/arthurwangtz/platformv-cbor][Wang_Tongzhou]
  CborKnownTPlatformvIsNameTag = 50001,
  // PlatformV_IS_VALUE; Ref: [https://github.com/arthurwangtz/platformv-cbor][Wang_Tongzhou]
  CborKnownTPlatformvIsValueTag = 50002,
  // PlatformV_HAS_COMPOSITE_VALUE; Ref: [https://github.com/arthurwangtz/platformv-cbor][Wang_Tongzhou]
  CborKnownTPlatformvHasCompositeValueTag = 50003,
  // PlatformV_HAS_MAPPED_VALUE; Ref: [https://github.com/arthurwangtz/platformv-cbor][Wang_Tongzhou]
  CborKnownTPlatformvHasMappedValueTag = 50004,
  // PlatformV_HAS_OBJ_ID; Ref: [https://github.com/arthurwangtz/platformv-cbor][Wang_Tongzhou]
  CborKnownTPlatformvHasObjIdTag = 50005,
  // PlatformV_HAS_OBJ_TAG; Ref: [https://github.com/arthurwangtz/platformv-cbor][Wang_Tongzhou]
  CborKnownTPlatformvHasObjTagTag = 50006,
  // PlatformV_HAS_CHILD; Ref: [https://github.com/arthurwangtz/platformv-cbor][Wang_Tongzhou]
  CborKnownTPlatformvHasChildTag = 50007,
  // PlatformV_HAS_PROPERTY; Ref: [https://github.com/arthurwangtz/platformv-cbor][Wang_Tongzhou]
  CborKnownTPlatformvHasPropertyTag = 50008,
  // PlatformV_HAS_META; Ref: [https://github.com/arthurwangtz/platformv-cbor][Wang_Tongzhou]
  CborKnownTPlatformvHasMetaTag = 50009,
  // PlatformV_HAS_EVENT; Ref: [https://github.com/arthurwangtz/platformv-cbor][Wang_Tongzhou]
  CborKnownTPlatformvHasEventTag = 50010,
  // PlatformV_HAS_ACTION; Ref: [https://github.com/arthurwangtz/platformv-cbor][Wang_Tongzhou]
  CborKnownTPlatformvHasActionTag = 50011,
  // PlatformV_IS_TYPE; Ref: [https://github.com/arthurwangtz/platformv-cbor][Wang_Tongzhou]
  CborKnownTPlatformvIsTypeTag = 50012,
  // Self-described CBOR; see Section 3.4.6; Ref: [RFC8949]
  CborSignatureTag = 55799,
  // indicates that the file contains CBOR Sequences; Ref: [RFC9277]
  CborKnownTIndicatesThatFileContainsCborSequencesTag = 55800,
  // indicates that the file starts with a CBOR-Labeled Non-CBOR Data label.; Ref: [RFC9277]
  CborKnownTIndicatesThatFileStartsWithCborLabeledNonCborDataLabelTag = 55801,
  // Compressed byte string; Ref: [https://github.com/dectris/documentation/blob/main/cbor/dectris-compression-tag.md][Kal_Conley]
  CborKnownTCompressedByteStringTag = 56500,
  // Identify and define a set of record structures (each a sequence of property names) that can be referenced as tags in the included value (and the scope for the record tag definitions); Ref: [https://github.com/kriszyp/cbor-records][Kris_Zyp]
  CborKnownTIdentDefineSetOfRecStrctThatCanBeRefAsTagsInIncValTag = 57342,
  // Identify and define a record structure (a sequence of property names), and use that record structure definition to interpret the included values.; Ref: [https://github.com/kriszyp/cbor-records][Kris_Zyp]
  CborKnownTIdentDefineRecStrctUseThatRecStrctDefInterpretIncValsTag = 57343,
  // The tagged CBOR array contains attestation evidence data with an Intel TEE quote.; Ref: [Shanwei_Cen]
  CborKnownTTaggedCborArrayContainsAttestEvidenceDataWithAnIntelTeeQuoteTag = 60000,
  // The tagged CBOR array contains attestation evidence data with an Intel TEE report.; Ref: [Shanwei_Cen]
  CborKnownTTaggedCborArrayContainsAttestEvidenceDataWithAnIntelTeeRptTag = 60001,
  // The tagged CBOR array contains attestation evidence data with an Intel SGX report.; Ref: [Shanwei_Cen]
  CborKnownTTaggedCborArrayContainsAttestEvidenceDataWithAnIntelSgxRptTag = 60002,
  // always invalid; see Section 10.1; Ref: [draft-bormann-cbor-notable-tags-02]
  CborKnownTAlwaysInvalidTag = 65535,
  // RAINS Message; Ref: [https://britram.github.io/rains-prototype][Brian_Trammell]
  CborKnownTRainsMsgTag = 15309736,
  // A CBOR encoded Openswan configuration file, as stored on disk forunit test cases.; Ref: [Michael_Richardson][Samir_Hussain]
  CborKnownTCborEncOpenswanConfigFileAsStoredOnDiskForunitTestCasesTag = 1330664270,
  // Concise Software Identifier (CoSWID); Ref: [RFC9393]
  CborKnownTConciseSoftwareIdTag = 1398229316,
  // Array of content-addressed blocks and ERIS read capabilities; Ref: [Endo_Renberg]
  CborKnownTArrayOfContentAddrBlocksErisReadCapTag = 1701996915,
  // ERIS-FS image header; Ref: [Endo_Renberg]
  CborKnownTErisFsImageHeaderTag = 1701996916,
  // always invalid; see Section 10.1; Ref: [draft-bormann-cbor-notable-tags-02]
  CborKnownTAlwaysInvalidTag = 4294967295,
  // Intel FPGA SPDM Manifest; Ref: [Andrew_Draper]
  CborKnownTIntelFpgaSpdmManifestTag = 4294967296,
  // always invalid; Section 10.1; Ref: [draft-bormann-cbor-notable-tags-02]
  CborKnownTAlwaysInvalidTag = 18446744073709551615
} CborKnownTags;

/* Start of cbor known tag feature flag autogenerated section */
/* #define the constants so we can check with #ifdef */
#define CborBase64Tag CborBase64Tag
#define CborBase64urlTag CborBase64urlTag
#define CborBigfloatTag CborBigfloatTag
#define CborCOSE_Encrypt0Tag CborCOSE_Encrypt0Tag
#define CborCOSE_EncryptTag CborCOSE_EncryptTag
#define CborCOSE_Mac0Tag CborCOSE_Mac0Tag
#define CborCOSE_MacTag CborCOSE_MacTag
#define CborCOSE_Sign1Tag CborCOSE_Sign1Tag
#define CborCOSE_SignTag CborCOSE_SignTag
#define CborDateTimeStringTag CborDateTimeStringTag
#define CborDecimalTag CborDecimalTag
#define CborEncodedCborTag CborEncodedCborTag
#define CborExpectedBase16Tag CborExpectedBase16Tag
#define CborExpectedBase64Tag CborExpectedBase64Tag
#define CborExpectedBase64urlTag CborExpectedBase64urlTag
#define CborKnownTACollectionOfNcmsMetadataElementsTag CborKnownTACollectionOfNcmsMetadataElementsTag
#define CborKnownTAConfidentialityClearanceTag CborKnownTAConfidentialityClearanceTag
#define CborKnownTAMetadataBindingTag CborKnownTAMetadataBindingTag
#define CborKnownTAbsentValueInACborArrayTag CborKnownTAbsentValueInACborArrayTag
#define CborKnownTAlternativesAsGivenByTheUintPlus128Tag CborKnownTAlternativesAsGivenByTheUintPlus128Tag
#define CborKnownTAlwaysInvalidTag CborKnownTAlwaysInvalidTag
#define CborKnownTArrayOfComplexNumbersInInterleavedFormTag CborKnownTArrayOfComplexNumbersInInterleavedFormTag
#define CborKnownTArrayOfContentAddrBlocksErisReadCapTag CborKnownTArrayOfContentAddrBlocksErisReadCapTag
#define CborKnownTBigfloatWithArbitraryExponentTag CborKnownTBigfloatWithArbitraryExponentTag
#define CborKnownTBinaryMimeMsgTag CborKnownTBinaryMimeMsgTag
#define CborKnownTBinaryUuidTag CborKnownTBinaryUuidTag
#define CborKnownTCaptureTag CborKnownTCaptureTag
#define CborKnownTCborEncOpenswanConfigFileAsStoredOnDiskForunitTestCasesTag CborKnownTCborEncOpenswanConfigFileAsStoredOnDiskForunitTestCasesTag
#define CborKnownTCborWebTokenTag CborKnownTCborWebTokenTag
#define CborKnownTCompressedByteStringTag CborKnownTCompressedByteStringTag
#define CborKnownTConciseSoftwareIdTag CborKnownTConciseSoftwareIdTag
#define CborKnownTCoseAlgorithmIdBaseHashValueTag CborKnownTCoseAlgorithmIdBaseHashValueTag
#define CborKnownTCoseStandaloneV2CountersignatureTag CborKnownTCoseStandaloneV2CountersignatureTag
#define CborKnownTDdosOpenThreatSignalingSigChnObjTag CborKnownTDdosOpenThreatSignalingSigChnObjTag
#define CborKnownTDecimalFractionWithArbitraryExponentTag CborKnownTDecimalFractionWithArbitraryExponentTag
#define CborKnownTDurationTag CborKnownTDurationTag
#define CborKnownTEcmascriptRegexpTag CborKnownTEcmascriptRegexpTag
#define CborKnownTEmbeddedJsonObjectTag CborKnownTEmbeddedJsonObjectTag
#define CborKnownTEncodedCborSequenceTag CborKnownTEncodedCborSequenceTag
#define CborKnownTErisBinaryReadCapabilityTag CborKnownTErisBinaryReadCapabilityTag
#define CborKnownTErisFsImageHeaderTag CborKnownTErisFsImageHeaderTag
#define CborKnownTExtendedBigfloatTag CborKnownTExtendedBigfloatTag
#define CborKnownTExtendedDecimalFractionTag CborKnownTExtendedDecimalFractionTag
#define CborKnownTExtendedRationalNumberTag CborKnownTExtendedRationalNumberTag
#define CborKnownTExtendedTimeTag CborKnownTExtendedTimeTag
#define CborKnownTExternalRefTag CborKnownTExternalRefTag
#define CborKnownTFullDateStringTag CborKnownTFullDateStringTag
#define CborKnownTGeoCoordRefSystemWktOrEpsgNumTag CborKnownTGeoCoordRefSystemWktOrEpsgNumTag
#define CborKnownTGeographicCoordinatesTag CborKnownTGeographicCoordinatesTag
#define CborKnownTGordianEnvelopeTag CborKnownTGordianEnvelopeTag
#define CborKnownTHexadecimalStringTag CborKnownTHexadecimalStringTag
#define CborKnownTHintThatIndicatesAnAddLvlOfIndirectionTag CborKnownTHintThatIndicatesAnAddLvlOfIndirectionTag
#define CborKnownTHomogeneousArrayTag CborKnownTHomogeneousArrayTag
#define CborKnownTIRegexpTag CborKnownTIRegexpTag
#define CborKnownTIdForAFhirConstantTag CborKnownTIdForAFhirConstantTag
#define CborKnownTIdTag CborKnownTIdTag
#define CborKnownTIdentDefineRecStrctUseThatRecStrctDefInterpretIncValsTag CborKnownTIdentDefineRecStrctUseThatRecStrctDefInterpretIncValsTag
#define CborKnownTIdentDefineSetOfRecStrctThatCanBeRefAsTagsInIncValTag CborKnownTIdentDefineSetOfRecStrctThatCanBeRefAsTagsInIncValTag
#define CborKnownTIeee754Binary128BigEndianTypedArrayTag CborKnownTIeee754Binary128BigEndianTypedArrayTag
#define CborKnownTIeee754Binary128LittleEndianTypedArrayTag CborKnownTIeee754Binary128LittleEndianTypedArrayTag
#define CborKnownTIeee754Binary16BigEndianTypedArrayTag CborKnownTIeee754Binary16BigEndianTypedArrayTag
#define CborKnownTIeee754Binary16LittleEndianTypedArrayTag CborKnownTIeee754Binary16LittleEndianTypedArrayTag
#define CborKnownTIeee754Binary32BigEndianTypedArrayTag CborKnownTIeee754Binary32BigEndianTypedArrayTag
#define CborKnownTIeee754Binary32LittleEndianTypedArrayTag CborKnownTIeee754Binary32LittleEndianTypedArrayTag
#define CborKnownTIeee754Binary64BigEndianTypedArrayTag CborKnownTIeee754Binary64BigEndianTypedArrayTag
#define CborKnownTIeee754Binary64LittleEndianTypedArrayTag CborKnownTIeee754Binary64LittleEndianTypedArrayTag
#define CborKnownTIndicatesThatFileContainsCborSequencesTag CborKnownTIndicatesThatFileContainsCborSequencesTag
#define CborKnownTIndicatesThatFileStartsWithCborLabeledNonCborDataLabelTag CborKnownTIndicatesThatFileStartsWithCborLabeledNonCborDataLabelTag
#define CborKnownTIntelFpgaSpdmManifestTag CborKnownTIntelFpgaSpdmManifestTag
#define CborKnownTInternationalizedResourceIdRefTag CborKnownTInternationalizedResourceIdRefTag
#define CborKnownTInternationalizedResourceIdTag CborKnownTInternationalizedResourceIdTag
#define CborKnownTInternetOfThingsDataPointTag CborKnownTInternetOfThingsDataPointTag
#define CborKnownTIpldContentIdTag CborKnownTIpldContentIdTag
#define CborKnownTIpv4Tag CborKnownTIpv4Tag
#define CborKnownTIpv6Tag CborKnownTIpv6Tag
#define CborKnownTLanguageTaggedStringTag CborKnownTLanguageTaggedStringTag
#define CborKnownTMapContainsOnlyKeysThatAreOfTypeTxtStrTag CborKnownTMapContainsOnlyKeysThatAreOfTypeTxtStrTag
#define CborKnownTMapDatatypeWithKeyValOpSetDeleteTag CborKnownTMapDatatypeWithKeyValOpSetDeleteTag
#define CborKnownTMarkValueAsHavingStringReferencesTag CborKnownTMarkValueAsHavingStringReferencesTag
#define CborKnownTMarkValueAsSharedTag CborKnownTMarkValueAsSharedTag
#define CborKnownTMathematicalFiniteSetTag CborKnownTMathematicalFiniteSetTag
#define CborKnownTMultiDimensionalArrayColumnMajorOrderTag CborKnownTMultiDimensionalArrayColumnMajorOrderTag
#define CborKnownTMultiDimensionalArrayRowMajorOrderTag CborKnownTMultiDimensionalArrayRowMajorOrderTag
#define CborKnownTNetworkAddressPrefixTag CborKnownTNetworkAddressPrefixTag
#define CborKnownTNetworkAddressTag CborKnownTNetworkAddressTag
#define CborKnownTNonUtf8Cesu8StringTag CborKnownTNonUtf8Cesu8StringTag
#define CborKnownTNonUtf8Mutf8StringTag CborKnownTNonUtf8Mutf8StringTag
#define CborKnownTNonUtf8Wtf8StringTag CborKnownTNonUtf8Wtf8StringTag
#define CborKnownTNumberOfDaysSinceTheEpochDate19700101Tag CborKnownTNumberOfDaysSinceTheEpochDate19700101Tag
#define CborKnownTObjectIdRelativeTo136141Tag CborKnownTObjectIdRelativeTo136141Tag
#define CborKnownTObjectIdTag CborKnownTObjectIdTag
#define CborKnownTObjectTypeIdTag CborKnownTObjectTypeIdTag
#define CborKnownTPeriodTag CborKnownTPeriodTag
#define CborKnownTPlatformvHasActionTag CborKnownTPlatformvHasActionTag
#define CborKnownTPlatformvHasChildTag CborKnownTPlatformvHasChildTag
#define CborKnownTPlatformvHasCompositeValueTag CborKnownTPlatformvHasCompositeValueTag
#define CborKnownTPlatformvHasEventTag CborKnownTPlatformvHasEventTag
#define CborKnownTPlatformvHasMappedValueTag CborKnownTPlatformvHasMappedValueTag
#define CborKnownTPlatformvHasMetaTag CborKnownTPlatformvHasMetaTag
#define CborKnownTPlatformvHasObjIdTag CborKnownTPlatformvHasObjIdTag
#define CborKnownTPlatformvHasObjTagTag CborKnownTPlatformvHasObjTagTag
#define CborKnownTPlatformvHasPropertyTag CborKnownTPlatformvHasPropertyTag
#define CborKnownTPlatformvIsIdTag CborKnownTPlatformvIsIdTag
#define CborKnownTPlatformvIsNameTag CborKnownTPlatformvIsNameTag
#define CborKnownTPlatformvIsTypeTag CborKnownTPlatformvIsTypeTag
#define CborKnownTPlatformvIsValueTag CborKnownTPlatformvIsValueTag
#define CborKnownTRainsMsgTag CborKnownTRainsMsgTag
#define CborKnownTRationalNumberTag CborKnownTRationalNumberTag
#define CborKnownTRefNthMarkedValueTag CborKnownTRefNthMarkedValueTag
#define CborKnownTRefTheNthPrevSeenStringTag CborKnownTRefTheNthPrevSeenStringTag
#define CborKnownTRelativeObjectIdTag CborKnownTRelativeObjectIdTag
#define CborKnownTSerialisedLangIndepObjWithTypeNameConstructorArgTag CborKnownTSerialisedLangIndepObjWithTypeNameConstructorArgTag
#define CborKnownTSerialisedPerlObjWithClassnameConstructorArgTag CborKnownTSerialisedPerlObjWithClassnameConstructorArgTag
#define CborKnownTSingleComplexNumberTag CborKnownTSingleComplexNumberTag
#define CborKnownTSint16BigEndianTypedArrayTag CborKnownTSint16BigEndianTypedArrayTag
#define CborKnownTSint16LittleEndianTypedArrayTag CborKnownTSint16LittleEndianTypedArrayTag
#define CborKnownTSint32BigEndianTypedArrayTag CborKnownTSint32BigEndianTypedArrayTag
#define CborKnownTSint32LittleEndianTypedArrayTag CborKnownTSint32LittleEndianTypedArrayTag
#define CborKnownTSint64BigEndianTypedArrayTag CborKnownTSint64BigEndianTypedArrayTag
#define CborKnownTSint64LittleEndianTypedArrayTag CborKnownTSint64LittleEndianTypedArrayTag
#define CborKnownTSint8TypedArrayTag CborKnownTSint8TypedArrayTag
#define CborKnownTTaggedCborArrayContainsAttestEvidenceDataWithAnIntelSgxRptTag CborKnownTTaggedCborArrayContainsAttestEvidenceDataWithAnIntelSgxRptTag
#define CborKnownTTaggedCborArrayContainsAttestEvidenceDataWithAnIntelTeeQuoteTag CborKnownTTaggedCborArrayContainsAttestEvidenceDataWithAnIntelTeeQuoteTag
#define CborKnownTTaggedCborArrayContainsAttestEvidenceDataWithAnIntelTeeRptTag CborKnownTTaggedCborArrayContainsAttestEvidenceDataWithAnIntelTeeRptTag
#define CborKnownTUint16BigEndianTypedArrayTag CborKnownTUint16BigEndianTypedArrayTag
#define CborKnownTUint16LittleEndianTypedArrayTag CborKnownTUint16LittleEndianTypedArrayTag
#define CborKnownTUint32BigEndianTypedArrayTag CborKnownTUint32BigEndianTypedArrayTag
#define CborKnownTUint32LittleEndianTypedArrayTag CborKnownTUint32LittleEndianTypedArrayTag
#define CborKnownTUint64BigEndianTypedArrayTag CborKnownTUint64BigEndianTypedArrayTag
#define CborKnownTUint64LittleEndianTypedArrayTag CborKnownTUint64LittleEndianTypedArrayTag
#define CborKnownTUint8TypedArrayClampedArithmeticTag CborKnownTUint8TypedArrayClampedArithmeticTag
#define CborKnownTUint8TypedArrayTag CborKnownTUint8TypedArrayTag
#define CborKnownTUniversalGeoAreaDescriptionDescriptionOfVelocityTag CborKnownTUniversalGeoAreaDescriptionDescriptionOfVelocityTag
#define CborKnownTUniversalGeoAreaDescriptionShapeTag CborKnownTUniversalGeoAreaDescriptionShapeTag
#define CborKnownTYangBitsDatatypeTag CborKnownTYangBitsDatatypeTag
#define CborKnownTYangEnumerationDatatypeTag CborKnownTYangEnumerationDatatypeTag
#define CborKnownTYangIdentityrefDatatypeTag CborKnownTYangIdentityrefDatatypeTag
#define CborKnownTYangInstanceIdDatatypeTag CborKnownTYangInstanceIdDatatypeTag
#define CborKnownTYangSchemaItemIdTag CborKnownTYangSchemaItemIdTag
#define CborMimeMessageTag CborMimeMessageTag
#define CborNegativeBignumTag CborNegativeBignumTag
#define CborPositiveBignumTag CborPositiveBignumTag
#define CborRegularExpressionTag CborRegularExpressionTag
#define CborSignatureTag CborSignatureTag
#define CborUnixTime_tTag CborUnixTime_tTag
#define CborUrlTag CborUrlTag
/* End of cbor known tag feature flag autogenerated section */

/* Error API */

typedef enum CborError {
    CborNoError = 0,

    /* errors in all modes */
    CborUnknownError,
    CborErrorUnknownLength,         /* request for length in array, map, or string with indeterminate length */
    CborErrorAdvancePastEOF,
    CborErrorIO,

    /* parser errors streaming errors */
    CborErrorGarbageAtEnd = 256,
    CborErrorUnexpectedEOF,
    CborErrorUnexpectedBreak,
    CborErrorUnknownType,           /* can only happen in major type 7 */
    CborErrorIllegalType,           /* type not allowed here */
    CborErrorIllegalNumber,
    CborErrorIllegalSimpleType,     /* types of value less than 32 encoded in two bytes */
    CborErrorNoMoreStringChunks,

    /* parser errors in strict mode parsing only */
    CborErrorUnknownSimpleType = 512,
    CborErrorUnknownTag,
    CborErrorInappropriateTagForType,
    CborErrorDuplicateObjectKeys,
    CborErrorInvalidUtf8TextString,
    CborErrorExcludedType,
    CborErrorExcludedValue,
    CborErrorImproperValue,
    CborErrorOverlongEncoding,
    CborErrorMapKeyNotString,
    CborErrorMapNotSorted,
    CborErrorMapKeysNotUnique,

    /* encoder errors */
    CborErrorTooManyItems = 768,
    CborErrorTooFewItems,

    /* internal implementation errors */
    CborErrorDataTooLarge = 1024,
    CborErrorNestingTooDeep,
    CborErrorUnsupportedType,
    CborErrorUnimplementedValidation,

    /* errors in converting to JSON */
    CborErrorJsonObjectKeyIsAggregate = 1280,
    CborErrorJsonObjectKeyNotString,
    CborErrorJsonNotImplemented,

    CborErrorOutOfMemory = (int) (~0U / 2 + 1),
    CborErrorInternalError = (int) (~0U / 2)    /* INT_MAX on two's complement machines */
} CborError;

CBOR_API const char *cbor_error_string(CborError error);

/* Encoder API */

typedef enum CborEncoderAppendType
{
    CborEncoderAppendCborData = 0,
    CborEncoderAppendStringData = 1
} CborEncoderAppendType;

typedef CborError (*CborEncoderWriteFunction)(void *, const void *, size_t, CborEncoderAppendType);

enum CborEncoderFlags
{
    CborIteratorFlag_WriterFunction         = 0x01,
    CborIteratorFlag_ContainerIsMap_        = 0x20
};

struct CborEncoder
{
    union {
        uint8_t *ptr;
        ptrdiff_t bytes_needed;
        CborEncoderWriteFunction writer;
    } data;
    uint8_t *end;
    size_t remaining;
    int flags;
};
typedef struct CborEncoder CborEncoder;

static const size_t CborIndefiniteLength = SIZE_MAX;

#ifndef CBOR_NO_ENCODER_API
CBOR_API void cbor_encoder_init(CborEncoder *encoder, uint8_t *buffer, size_t size, int flags);
CBOR_API void cbor_encoder_init_writer(CborEncoder *encoder, CborEncoderWriteFunction writer, void *);
CBOR_API CborError cbor_encode_uint(CborEncoder *encoder, uint64_t value);
CBOR_API CborError cbor_encode_int(CborEncoder *encoder, int64_t value);
CBOR_API CborError cbor_encode_negative_int(CborEncoder *encoder, uint64_t absolute_value);
CBOR_API CborError cbor_encode_simple_value(CborEncoder *encoder, uint8_t value);
CBOR_API CborError cbor_encode_tag(CborEncoder *encoder, CborTag tag);
CBOR_API CborError cbor_encode_text_string(CborEncoder *encoder, const char *string, size_t length);
CBOR_INLINE_API CborError cbor_encode_text_stringz(CborEncoder *encoder, const char *string)
{ return cbor_encode_text_string(encoder, string, strlen(string)); }
CBOR_API CborError cbor_encode_byte_string(CborEncoder *encoder, const uint8_t *string, size_t length);
CBOR_API CborError cbor_encode_floating_point(CborEncoder *encoder, CborType fpType, const void *value);

CBOR_INLINE_API CborError cbor_encode_boolean(CborEncoder *encoder, bool value)
{ return cbor_encode_simple_value(encoder, (int)value - 1 + (CborBooleanType & 0x1f)); }
CBOR_INLINE_API CborError cbor_encode_null(CborEncoder *encoder)
{ return cbor_encode_simple_value(encoder, CborNullType & 0x1f); }
CBOR_INLINE_API CborError cbor_encode_undefined(CborEncoder *encoder)
{ return cbor_encode_simple_value(encoder, CborUndefinedType & 0x1f); }

CBOR_INLINE_API CborError cbor_encode_half_float(CborEncoder *encoder, const void *value)
{ return cbor_encode_floating_point(encoder, CborHalfFloatType, value); }
CBOR_API CborError cbor_encode_float_as_half_float(CborEncoder *encoder, float value);
CBOR_INLINE_API CborError cbor_encode_float(CborEncoder *encoder, float value)
{ return cbor_encode_floating_point(encoder, CborFloatType, &value); }
CBOR_INLINE_API CborError cbor_encode_double(CborEncoder *encoder, double value)
{ return cbor_encode_floating_point(encoder, CborDoubleType, &value); }

CBOR_API CborError cbor_encoder_create_array(CborEncoder *parentEncoder, CborEncoder *arrayEncoder, size_t length);
CBOR_API CborError cbor_encoder_create_map(CborEncoder *parentEncoder, CborEncoder *mapEncoder, size_t length);
CBOR_API CborError cbor_encoder_close_container(CborEncoder *parentEncoder, const CborEncoder *containerEncoder);
CBOR_API CborError cbor_encoder_close_container_checked(CborEncoder *parentEncoder, const CborEncoder *containerEncoder);

CBOR_INLINE_API uint8_t *_cbor_encoder_get_buffer_pointer(const CborEncoder *encoder)
{
    return encoder->data.ptr;
}

CBOR_INLINE_API size_t cbor_encoder_get_buffer_size(const CborEncoder *encoder, const uint8_t *buffer)
{
    return (size_t)(encoder->data.ptr - buffer);
}

CBOR_INLINE_API size_t cbor_encoder_get_extra_bytes_needed(const CborEncoder *encoder)
{
    return encoder->end ? 0 : (size_t)encoder->data.bytes_needed;
}
#endif /* CBOR_NO_ENCODER_API */

/* Parser API */

enum CborParserGlobalFlags
{
    CborParserFlag_ExternalSource           = 0x01
};

enum CborParserIteratorFlags
{
    /* used for all types, but not during string chunk iteration
     * (values are static-asserted, don't change) */
    CborIteratorFlag_IntegerValueIs64Bit    = 0x01,
    CborIteratorFlag_IntegerValueTooLarge   = 0x02,

    /* used only for CborIntegerType */
    CborIteratorFlag_NegativeInteger        = 0x04,

    /* used only during string iteration */
    CborIteratorFlag_BeforeFirstStringChunk = 0x04,
    CborIteratorFlag_IteratingStringChunks  = 0x08,

    /* used for arrays, maps and strings, including during chunk iteration */
    CborIteratorFlag_UnknownLength          = 0x10,

    /* used for maps, but must be kept for all types
     * (ContainerIsMap value must be CborMapType - CborArrayType) */
    CborIteratorFlag_ContainerIsMap         = 0x20,
    CborIteratorFlag_NextIsMapKey           = 0x40
};

struct CborValue;
struct CborParserOperations
{
    bool (*can_read_bytes)(void *token, size_t len);
    void *(*read_bytes)(void *token, void *dst, size_t offset, size_t len);
    void (*advance_bytes)(void *token, size_t len);
    CborError (*transfer_string)(void *token, const void **userptr, size_t offset, size_t len);
};

struct CborParser
{
    union {
        const uint8_t *end;
        const struct CborParserOperations *ops;
    } source;
    enum CborParserGlobalFlags flags;
};
typedef struct CborParser CborParser;

struct CborValue
{
    const CborParser *parser;
    union {
        const uint8_t *ptr;
        void *token;
    } source;
    uint32_t remaining;
    uint16_t extra;
    uint8_t type;
    uint8_t flags;
};
typedef struct CborValue CborValue;

#ifndef CBOR_NO_PARSER_API
CBOR_API CborError cbor_parser_init(const uint8_t *buffer, size_t size, uint32_t flags, CborParser *parser, CborValue *it);
CBOR_API CborError cbor_parser_init_reader(const struct CborParserOperations *ops, CborParser *parser, CborValue *it, void *token);

CBOR_API CborError cbor_value_validate_basic(const CborValue *it);

CBOR_INLINE_API bool cbor_value_at_end(const CborValue *it)
{ return it->remaining == 0; }
CBOR_INLINE_API const uint8_t *cbor_value_get_next_byte(const CborValue *it)
{ return it->source.ptr; }
CBOR_API CborError cbor_value_reparse(CborValue *it);
CBOR_API CborError cbor_value_advance_fixed(CborValue *it);
CBOR_API CborError cbor_value_advance(CborValue *it);
CBOR_INLINE_API bool cbor_value_is_container(const CborValue *it)
{ return it->type == CborArrayType || it->type == CborMapType; }
CBOR_API CborError cbor_value_enter_container(const CborValue *it, CborValue *recursed);
CBOR_API CborError cbor_value_leave_container(CborValue *it, const CborValue *recursed);

CBOR_PRIVATE_API uint64_t _cbor_value_decode_int64_internal(const CborValue *value);
CBOR_INLINE_API uint64_t _cbor_value_extract_int64_helper(const CborValue *value)
{
    return value->flags & CborIteratorFlag_IntegerValueTooLarge ?
                _cbor_value_decode_int64_internal(value) : value->extra;
}

CBOR_INLINE_API bool cbor_value_is_valid(const CborValue *value)
{ return value && value->type != CborInvalidType; }
CBOR_INLINE_API CborType cbor_value_get_type(const CborValue *value)
{ return (CborType)value->type; }

/* Null & undefined type */
CBOR_INLINE_API bool cbor_value_is_null(const CborValue *value)
{ return value->type == CborNullType; }
CBOR_INLINE_API bool cbor_value_is_undefined(const CborValue *value)
{ return value->type == CborUndefinedType; }

/* Booleans */
CBOR_INLINE_API bool cbor_value_is_boolean(const CborValue *value)
{ return value->type == CborBooleanType; }
CBOR_INLINE_API CborError cbor_value_get_boolean(const CborValue *value, bool *result)
{
    assert(cbor_value_is_boolean(value));
    *result = !!value->extra;
    return CborNoError;
}

/* Simple types */
CBOR_INLINE_API bool cbor_value_is_simple_type(const CborValue *value)
{ return value->type == CborSimpleType; }
CBOR_INLINE_API CborError cbor_value_get_simple_type(const CborValue *value, uint8_t *result)
{
    assert(cbor_value_is_simple_type(value));
    *result = (uint8_t)value->extra;
    return CborNoError;
}

/* Integers */
CBOR_INLINE_API bool cbor_value_is_integer(const CborValue *value)
{ return value->type == CborIntegerType; }
CBOR_INLINE_API bool cbor_value_is_unsigned_integer(const CborValue *value)
{ return cbor_value_is_integer(value) && (value->flags & CborIteratorFlag_NegativeInteger) == 0; }
CBOR_INLINE_API bool cbor_value_is_negative_integer(const CborValue *value)
{ return cbor_value_is_integer(value) && (value->flags & CborIteratorFlag_NegativeInteger); }

CBOR_INLINE_API CborError cbor_value_get_raw_integer(const CborValue *value, uint64_t *result)
{
    assert(cbor_value_is_integer(value));
    *result = _cbor_value_extract_int64_helper(value);
    return CborNoError;
}

CBOR_INLINE_API CborError cbor_value_get_uint64(const CborValue *value, uint64_t *result)
{
    assert(cbor_value_is_unsigned_integer(value));
    *result = _cbor_value_extract_int64_helper(value);
    return CborNoError;
}

CBOR_INLINE_API CborError cbor_value_get_int64(const CborValue *value, int64_t *result)
{
    assert(cbor_value_is_integer(value));
    *result = (int64_t) _cbor_value_extract_int64_helper(value);
    if (value->flags & CborIteratorFlag_NegativeInteger)
        *result = -*result - 1;
    return CborNoError;
}

CBOR_INLINE_API CborError cbor_value_get_int(const CborValue *value, int *result)
{
    assert(cbor_value_is_integer(value));
    *result = (int) _cbor_value_extract_int64_helper(value);
    if (value->flags & CborIteratorFlag_NegativeInteger)
        *result = -*result - 1;
    return CborNoError;
}

CBOR_API CborError cbor_value_get_int64_checked(const CborValue *value, int64_t *result);
CBOR_API CborError cbor_value_get_int_checked(const CborValue *value, int *result);

CBOR_INLINE_API bool cbor_value_is_length_known(const CborValue *value)
{ return (value->flags & CborIteratorFlag_UnknownLength) == 0; }

/* Tags */
CBOR_INLINE_API bool cbor_value_is_tag(const CborValue *value)
{ return value->type == CborTagType; }
CBOR_INLINE_API CborError cbor_value_get_tag(const CborValue *value, CborTag *result)
{
    assert(cbor_value_is_tag(value));
    *result = _cbor_value_extract_int64_helper(value);
    return CborNoError;
}
CBOR_API CborError cbor_value_skip_tag(CborValue *it);

/* Strings */
CBOR_INLINE_API bool cbor_value_is_byte_string(const CborValue *value)
{ return value->type == CborByteStringType; }
CBOR_INLINE_API bool cbor_value_is_text_string(const CborValue *value)
{ return value->type == CborTextStringType; }

CBOR_INLINE_API CborError cbor_value_get_string_length(const CborValue *value, size_t *length)
{
    uint64_t v;
    assert(cbor_value_is_byte_string(value) || cbor_value_is_text_string(value));
    if (!cbor_value_is_length_known(value))
        return CborErrorUnknownLength;
    v = _cbor_value_extract_int64_helper(value);
    *length = (size_t)v;
    if (*length != v)
        return CborErrorDataTooLarge;
    return CborNoError;
}

CBOR_PRIVATE_API CborError _cbor_value_copy_string(const CborValue *value, void *buffer,
                                                   size_t *buflen, CborValue *next);
CBOR_PRIVATE_API CborError _cbor_value_dup_string(const CborValue *value, void **buffer,
                                                  size_t *buflen, CborValue *next);

CBOR_API CborError cbor_value_calculate_string_length(const CborValue *value, size_t *length);

CBOR_INLINE_API CborError cbor_value_copy_text_string(const CborValue *value, char *buffer,
                                                      size_t *buflen, CborValue *next)
{
    assert(cbor_value_is_text_string(value));
    return _cbor_value_copy_string(value, buffer, buflen, next);
}
CBOR_INLINE_API CborError cbor_value_copy_byte_string(const CborValue *value, uint8_t *buffer,
                                                      size_t *buflen, CborValue *next)
{
    assert(cbor_value_is_byte_string(value));
    return _cbor_value_copy_string(value, buffer, buflen, next);
}

CBOR_INLINE_API CborError cbor_value_dup_text_string(const CborValue *value, char **buffer,
                                                     size_t *buflen, CborValue *next)
{
    assert(cbor_value_is_text_string(value));
    return _cbor_value_dup_string(value, (void **)buffer, buflen, next);
}
CBOR_INLINE_API CborError cbor_value_dup_byte_string(const CborValue *value, uint8_t **buffer,
                                                     size_t *buflen, CborValue *next)
{
    assert(cbor_value_is_byte_string(value));
    return _cbor_value_dup_string(value, (void **)buffer, buflen, next);
}

CBOR_PRIVATE_API CborError _cbor_value_get_string_chunk_size(const CborValue *value, size_t *len);
CBOR_INLINE_API CborError cbor_value_get_string_chunk_size(const CborValue *value, size_t *len)
{
    assert(value->flags & CborIteratorFlag_IteratingStringChunks);
    return _cbor_value_get_string_chunk_size(value, len);
}

CBOR_INLINE_API bool cbor_value_string_iteration_at_end(const CborValue *value)
{
    size_t dummy;
    return cbor_value_get_string_chunk_size(value, &dummy) == CborErrorNoMoreStringChunks;
}

CBOR_PRIVATE_API CborError _cbor_value_begin_string_iteration(CborValue *value);
CBOR_INLINE_API CborError cbor_value_begin_string_iteration(CborValue *value)
{
    assert(cbor_value_is_text_string(value) || cbor_value_is_byte_string(value));
    assert(!(value->flags & CborIteratorFlag_IteratingStringChunks));
    return _cbor_value_begin_string_iteration(value);
}

CBOR_PRIVATE_API CborError _cbor_value_finish_string_iteration(CborValue *value);
CBOR_INLINE_API CborError cbor_value_finish_string_iteration(CborValue *value)
{
    assert(cbor_value_string_iteration_at_end(value));
    return _cbor_value_finish_string_iteration(value);
}

CBOR_PRIVATE_API CborError _cbor_value_get_string_chunk(const CborValue *value, const void **bufferptr,
                                                        size_t *len, CborValue *next);
CBOR_INLINE_API CborError cbor_value_get_text_string_chunk(const CborValue *value, const char **bufferptr,
                                                           size_t *len, CborValue *next)
{
    assert(cbor_value_is_text_string(value));
    return _cbor_value_get_string_chunk(value, (const void **)bufferptr, len, next);
}
CBOR_INLINE_API CborError cbor_value_get_byte_string_chunk(const CborValue *value, const uint8_t **bufferptr,
                                                           size_t *len, CborValue *next)
{
    assert(cbor_value_is_byte_string(value));
    return _cbor_value_get_string_chunk(value, (const void **)bufferptr, len, next);
}

CBOR_API CborError cbor_value_text_string_equals(const CborValue *value, const char *string, bool *result);

/* Maps and arrays */
CBOR_INLINE_API bool cbor_value_is_array(const CborValue *value)
{ return value->type == CborArrayType; }
CBOR_INLINE_API bool cbor_value_is_map(const CborValue *value)
{ return value->type == CborMapType; }

CBOR_INLINE_API CborError cbor_value_get_array_length(const CborValue *value, size_t *length)
{
    uint64_t v;
    assert(cbor_value_is_array(value));
    if (!cbor_value_is_length_known(value))
        return CborErrorUnknownLength;
    v = _cbor_value_extract_int64_helper(value);
    *length = (size_t)v;
    if (*length != v)
        return CborErrorDataTooLarge;
    return CborNoError;
}

CBOR_INLINE_API CborError cbor_value_get_map_length(const CborValue *value, size_t *length)
{
    uint64_t v;
    assert(cbor_value_is_map(value));
    if (!cbor_value_is_length_known(value))
        return CborErrorUnknownLength;
    v = _cbor_value_extract_int64_helper(value);
    *length = (size_t)v;
    if (*length != v)
        return CborErrorDataTooLarge;
    return CborNoError;
}

CBOR_API CborError cbor_value_map_find_value(const CborValue *map, const char *string, CborValue *element);

/* Floating point */
CBOR_INLINE_API bool cbor_value_is_half_float(const CborValue *value)
{ return value->type == CborHalfFloatType; }
CBOR_API CborError cbor_value_get_half_float_as_float(const CborValue *value, float *result);
CBOR_INLINE_API CborError cbor_value_get_half_float(const CborValue *value, void *result)
{
    assert(cbor_value_is_half_float(value));
    assert((value->flags & CborIteratorFlag_IntegerValueTooLarge) == 0);

    /* size has already been computed */
    memcpy(result, &value->extra, sizeof(value->extra));
    return CborNoError;
}

CBOR_INLINE_API bool cbor_value_is_float(const CborValue *value)
{ return value->type == CborFloatType; }
CBOR_INLINE_API CborError cbor_value_get_float(const CborValue *value, float *result)
{
    uint32_t data;
    assert(cbor_value_is_float(value));
    assert(value->flags & CborIteratorFlag_IntegerValueTooLarge);
    data = (uint32_t)_cbor_value_decode_int64_internal(value);
    memcpy(result, &data, sizeof(*result));
    return CborNoError;
}

CBOR_INLINE_API bool cbor_value_is_double(const CborValue *value)
{ return value->type == CborDoubleType; }
CBOR_INLINE_API CborError cbor_value_get_double(const CborValue *value, double *result)
{
    uint64_t data;
    assert(cbor_value_is_double(value));
    assert(value->flags & CborIteratorFlag_IntegerValueTooLarge);
    data = _cbor_value_decode_int64_internal(value);
    memcpy(result, &data, sizeof(*result));
    return CborNoError;
}

/* Validation API */
#ifndef CBOR_NO_VALIDATION_API

enum CborValidationFlags {
    /* Bit mapping:
     *  bits 0-7 (8 bits):      canonical format
     *  bits 8-11 (4 bits):     canonical format & strict mode
     *  bits 12-20 (8 bits):    strict mode
     *  bits 21-31 (10 bits):   other
     */

    CborValidateShortestIntegrals           = 0x0001,
    CborValidateShortestFloatingPoint       = 0x0002,
    CborValidateShortestNumbers             = CborValidateShortestIntegrals | CborValidateShortestFloatingPoint,
    CborValidateNoIndeterminateLength       = 0x0100,
    CborValidateMapIsSorted                 = 0x0200 | CborValidateNoIndeterminateLength,

    CborValidateCanonicalFormat             = 0x0fff,

    CborValidateMapKeysAreUnique            = 0x1000 | CborValidateMapIsSorted,
    CborValidateTagUse                      = 0x2000,
    CborValidateUtf8                        = 0x4000,

    CborValidateStrictMode                  = 0xfff00,

    CborValidateMapKeysAreString            = 0x100000,
    CborValidateNoUndefined                 = 0x200000,
    CborValidateNoTags                      = 0x400000,
    CborValidateFiniteFloatingPoint         = 0x800000,
    /* unused                               = 0x1000000, */
    /* unused                               = 0x2000000, */

    CborValidateNoUnknownSimpleTypesSA      = 0x4000000,
    CborValidateNoUnknownSimpleTypes        = 0x8000000 | CborValidateNoUnknownSimpleTypesSA,
    CborValidateNoUnknownTagsSA             = 0x10000000,
    CborValidateNoUnknownTagsSR             = 0x20000000 | CborValidateNoUnknownTagsSA,
    CborValidateNoUnknownTags               = 0x40000000 | CborValidateNoUnknownTagsSR,

    CborValidateCompleteData                = (int)0x80000000,

    CborValidateStrictest                   = (int)~0U,
    CborValidateBasic                       = 0
};

CBOR_API CborError cbor_value_validate(const CborValue *it, uint32_t flags);
#endif /* CBOR_NO_VALIDATION_API */

/* Human-readable (dump) API */
#ifndef CBOR_NO_PRETTY_API

enum CborPrettyFlags {
    CborPrettyNumericEncodingIndicators     = 0x01,
    CborPrettyTextualEncodingIndicators     = 0,

    CborPrettyIndicateIndeterminateLength   = 0x02,
    CborPrettyIndicateIndetermineLength     = CborPrettyIndicateIndeterminateLength, /* deprecated */
    CborPrettyIndicateOverlongNumbers       = 0x04,

    CborPrettyShowStringFragments           = 0x100,
    CborPrettyMergeStringFragments          = 0,

    CborPrettyDefaultFlags          = CborPrettyIndicateIndeterminateLength
};

typedef CborError (*CborStreamFunction)(void *token, const char *fmt, ...)
#ifdef __GNUC__
    __attribute__((__format__(printf, 2, 3)))
#endif
;

CBOR_API CborError cbor_value_to_pretty_stream(CborStreamFunction streamFunction, void *token, CborValue *value, int flags);

/* The following API requires a hosted C implementation (uses FILE*) */
#if !defined(__STDC_HOSTED__) || __STDC_HOSTED__-0 == 1
CBOR_API CborError cbor_value_to_pretty_advance_flags(FILE *out, CborValue *value, int flags);
CBOR_API CborError cbor_value_to_pretty_advance(FILE *out, CborValue *value);
CBOR_INLINE_API CborError cbor_value_to_pretty(FILE *out, const CborValue *value)
{
    CborValue copy = *value;
    return cbor_value_to_pretty_advance_flags(out, &copy, CborPrettyDefaultFlags);
}
#endif /* __STDC_HOSTED__ check */

#endif /* CBOR_NO_PRETTY_API */

#endif /* CBOR_NO_PARSER_API */

#ifdef __cplusplus
}
#endif

#endif /* CBOR_H */
